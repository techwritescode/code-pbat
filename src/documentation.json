{
    "SET": "## SET\n\nTo store a string or number\n\n```pbat\nSET \"U8\" \"MY_DIGIT\" \"235\"\n```\n\n```pbat\nSET \"S32\" \"MY_OTHER_DIGIT\" \"-3420\"\n```\n\nOnce the type is set, you can assign a new value to the variable :\n\n```pbat\nSET \"MY_DIGIT\" \"34\"\n```",
    "UNSET": "## UNSET\n\nTo remove a string or number\n\n```pbat\nUNSET \"MY_DIGIT\"\n```",
    "SAVEVARS": "## SAVEVARS\n\nSave variables that start with BM.CNF_\n\n```pbat\nIF FAIL SAVEVARS \"BM.CNF_*\" \"$BM.BM_PATH$/CONFIG/BMCONF.PBT\"\n        MESSAGE \"$BM.TXT_SAVE_CONF_FAIL$\"\n    ELSE\n        SET \"BM.CONFIG_CHANGED\" \"0\"\n    ENDIF\n    GOTO \"MENU_MAIN\"\nENDIF\n```",
    "ECHO": "## ECHO\nTo output text to console (PS2Client)\n\n```pbat\nECHO \"The value of MY_DIGIT is : $MY_DIGIT$\"\n```\n\nwill return the text and the contain of the variable in the output console which will be in most case the console where you launched ps2client.",
    "MESSAGE": "## MESSAGE\nTo display text on the tv screen\n\n```pbat\nMESSAGE \"Installation Complete!\"\n```\n\nwill return the text Installation Complete! on the TV screen.",
    "ADDWIDGET": "## ADDWIDGET\nWidgets is used to display menus in the screen. There are many Widget types to feet different needs.\n\nTo display a menu item\n\n```pbat\nADDWIDGET \"LABEL\" \"Main Menu\"\n```",
    "CLEARWIDGETS": "## CLEARWIDGETS\nWill clear the screen of all widgets.\n\n```pbat\nCLEARWIDGETS\n```",
    "SETTITLE": "## SETTITLE\n`SETTITLE` will set the title of the current screen.\n\n```pbat\nSETTITLE \"Install App to...\n```",
    "EVAL": "## EVAL\nUsed with `ADDWIDGET` and `SETTITLE` to evaluate nested variables\n\n```pbat\nEVAL SETTITLE \"$$BM.TXT_$ARG2$_$ARG3$_FROM$$\"\n```\n\n```pbat\nEVAL ADDWIDGET \"LABEL\" \"$$BM.TXT_$ARG3$$$\"\n```",
    "GOTO": "## GOTO\nA PBAT script is divided into sections. You can define a new section using the sign :\n\nYou can navigate thru sections with the `GOTO` command.\n\nDo NOT use `GOTO` to jump to a label which is within an IF statement! Doing so will result in script failure.\n\n`GOTO` does NOT support passing arguments/values!\n\nHere is a piece of code to understand how sections work :\n\n```pbat\nGOTO \"MAIN_MENU\"\n\n:A_SECTION\n    ECHO \"We are in the A_SECTION section\".\n\n:MAIN_MENU\n    ADDWIDGET INT \"Value to export\" \"Choose a number that will be exported to another section\" \"THE_NUMBER\" \"0\" \"10\" \"1\"\n    ADDWIDGET CALL \"Go to Config Menu\" \"Will display the Config Menu\" \"$ARG0$\" \"CONFIG_MENU\" \" \"$THE_NUMBER$\"\n\n:CONFIG_MENU\n    CLEARWIDGETS\n    MESSAGE \"The Number you choose was : $ARG2$\"\n```\n\nIf this script is called, the section `MAIN_MENU` will be executed first because of the `GOTO`. In `MAIN_MENU`, the variable `$THE_NUMBER$` is choosen by the user and the code will jump to `CONFIG_MENU` with the variable exported.",
    "IF": "## IF\nAll conditions will start with `IF`. There exists `ELSEIF`, `ELSE` and must be terminated with `ENDIF`. See below for further usage.\n\n### EQU, NEQ / GTE, GT, LTE, LT\nNumerical Conditions\n- `EQU` = Equal\n- `NEQ` = NOT Equal\n- `EQUC` = Equal ? (unknown...)\n- `NEQC` = NOT Equal ? (unknown...)\n- `GTE` = Greater than or equal\n- `GT` = Greater than\n- `LTE` = Less than or equal\n- `LT` = Less than or equal\n\n```pbat\nIF EQU \"$MY_VARIABLE$\" \"1\"\n    MESSAGE \"The Variable was equal to 1\"\nELSE\n    MESSAGE \"The Variable was not equal to 1\"\nENDIF\n```\nYou can also turn this code differently:\n\n```pbat\nIF NEQ \"$MY_VARIABLE$\" \"0\"\n    MESSAGE \"The Variable was not equal to 0\"\nELSE\n    MESSAGE \"The Variable was equal to 0\"\nENDIF\n```\nYou can evaluate if a number is larger or less than or equal another variable:\n\n```pbat\nIF GTE \"$BM.BIOS_MAJOR_VER$$BM.BIOS_MINOR_VER$\" \"220\"\n    MESSAGE \"Unit is SCPH-75k or later and does not support HDD!\"\nENDIF\n```\n### EXISTS\nTo know if a file/folder exists or not. This command should be used in a IF statement\n\n\n```pbat\nIF EXISTS \"mc0:/MYFOLDER/MYSCRIPT.PBT\"\n    COPY \"mc0:/MYFOLDER/MYSCRIPT.PBT\" \"mass:/MYFOLDER/MYSCRIPT.PBT\"\nENDIF\n```\n### MATCHES\nTo know if a STRING matches or not. This command should be used in a `IF` statement. If a wildcard is used, best to use it in first part of comparison. Second comparison should have NO wildcards.\n\n```pbat\nIF MATCHES \"SCPH-300*\" \"$BM.CONSOLE_MODEL$\"\n    MESSAGE \"Console is SCPH-300XX\"\nENDIF\n```\n### FAIL\nCombine with other file manipulation commands, `LOADEXEC` or `LOADSRAM`\n\n```pbat\nIF FAIL COPY \"mass:/MYFOLDER\" \"mc0:/MYFOLDER\n    MESSAGE \"Failed to copy MYFOLDER\"\n    IF FAIL RRM \"mc0:/MYFOLDER\"\n        MESSAGE \"Failed to remove mc0:/MYFOLDER!\"\n        RETURN -1\n    ENDIF\nENDIF\n```\n### MODLOADED\nDetemines if IRX is loaded. Unsure how to find names of loaded IRX as is not ELF name.\n\n```pbat\nIF NOT MODLOADED \"dev9_driver\"\n    IF FAIL LOADEXEC \"IRX\" \"$BM.DRIVER_PATH$/PS2DEV9.IRX\"\n        ECHO \"Failed loading PS2DEV9.IRX!\"\n        RETURN -1\n    ENDIF\nENDIF\nISIN\n```\n\nDetermines if text is within a file.\n\n```pbat\nIF ISIN \"MY_FILE.TXT\" \"HELLO_WORLD\"\n    MESSAGE \"HELLO WORLD!\"\nENDIF\n```\n### NOT\nCombine with `IF`/`ELSEIF` and another condition. Do NOT use with `EQU`, `EQUC`, `NEQ`, `NEQC`\n\n\n```pbat\nIF NOT EXISTS \"mc0:/SYS-CONF/IPCONFIG.DAT\"\n    FPRINT \"mc0:/SYS-CONF/IPCONFIG.DAT\" \"192.168.0.10\"\nENDIF\n```",
    "ELSE": "## ELSEIF / ELSE\nYou can imbricate more than one `IF` with the keyword `ELSEIF`\n\n```pbat\nIF EQU \"$MY_VARIABLE$\" \"1\"\n    MESSAGE \"The Variable was equal to 1\"\nELSEIF EQU \"$MY_VARIABLE$\" \"2\"\n    MESSAGE \"The Variable was equal to 2\"\nENDIF\n```\n\nYou'll use the `ELSEIF` statement when you want to keep testing for values.\n\nYou will use the `ELSE` statement when none are true, the last `ELSE` will be executed.\n\n```pbat\nIF EQU \"$MY_VARIABLE$\" \"1\"\n    MESSAGE \"The Variable was equal to 1\"\nELSE \n    MESSAGE \"The Variable was something other than 1\"\nENDIF\n```",
    "ELSEIF": "## ELSEIF / ELSE\nYou can imbricate more than one `IF` with the keyword `ELSEIF`\n\n```pbat\nIF EQU \"$MY_VARIABLE$\" \"1\"\n    MESSAGE \"The Variable was equal to 1\"\nELSEIF EQU \"$MY_VARIABLE$\" \"2\"\n    MESSAGE \"The Variable was equal to 2\"\nENDIF\n```\n\nYou'll use the `ELSEIF` statement when you want to keep testing for values.\n\nYou will use the `ELSE` statement when none are true, the last `ELSE` will be executed.\n\n```pbat\nIF EQU \"$MY_VARIABLE$\" \"1\"\n    MESSAGE \"The Variable was equal to 1\"\nELSE \n    MESSAGE \"The Variable was something other than 1\"\nENDIF\n```",
    "ENDIF": "## ENDIF\nAny condition starting with `IF` must have an `ENDIF`\n\n```pbat\nIF\nELSEIF\nELSEIF\nELSE\nENDIF\n```",
    "COPY": "## COPY\nTo copy file/directory from source to destination\n\n```pbat\nCOPY \"host:/FOLDER\" \"mass:/FOLDER/FOLDER2\"\n```\n\nwill copy contents source folder to destintaion folder if intermediary folders exist.\n\n```pbat\nCOPY \"host:/FOLDER1/FILE.TXT\" \"mass:/FOLDER1/FOLDER2/FILE.TXT\"\n```\n\nwill copy the single file, but will NOT create destination folder structure if it does not exist.\n\nNotes: copying a file to a file only works if prior directories already exist on destination.\n\n```pbat\nCOPY \"host:/FOLDER\" \"mass:/FOLDER1NOTEXISTS/FOLDER2/FILE.TXT\"\n^DOES NOT WORK!\n```\n\n```pbat\nCOPY \"host:/FOLDER\" \"mass:/FOLDER1NOTEXISTS/FOLDER2/\"\n```\n\nThis does work to create an empty `mass:/FOLDER1` but will say it fails if used with `IF COPY FAIL`. Note the ending `/`",
    "RM": "## RM/RRM\nTo delete a file or directory\n\n- `RM` Remove\n- `RRM` Recursive Remove\n\n```pbat\nRRM \"mc0:/TMPFOLDER\"\n```\n\nMost likely same script as informed by Crystal Chip Team since there is little reason for RM to exist.",
    "RRM": "## RM/RRM\nTo delete a file or directory\n\n- `RM` Remove\n- `RRM` Recursive Remove\n\n```pbat\nRRM \"mc0:/TMPFOLDER\"\n```\n\nMost likely same script as informed by Crystal Chip Team since there is little reason for RM to exist.",
    "FORMAT": "## FORMAT\nTo erase file system and initialize Memory Card or Crystal Chip flash\n\n```pbat\nFORMAT \"dffs:/\"\n```",
    "MKDIR": "## MKDIR\nTo create a new folder.\n\n```pbat\nMKDIR \"mass:/MYFOLDER\"\n```\nwill create a folder `MYFOLDER` in the USB mass storage.\n\nNote: `MKDIR` will not create mutliple folders for example if `MYFOLDER`, `FOLDER` and `FOLDER3` do not exist:\n\n```pbat\nIF NOT EXISTS \"mass:/MYFOLDER/FOLDER2/FOLDER3\"\n    IF FAIL MKDIR \"mass:/MYFOLDER/FOLDER2/FOLDER3\"\n        MESSAGE \"FAILED TO CREATE DIRECTORY!\"\n    ENDIF\nENDIF\n```\nThe workaround is to exploit a bug that thinks it failed\n\n```pbat\nCOPY $PWD$ \"mass:/MYFOLDER/MYFOLDER2/MYFOLDER3\"\n```\nDO NOT PRECEDE WITH `IF FAIL` as it does think it failed. Contents of folders will not be harmed in my testing if some of it exists.",
    "REDIRFILE": "## REDIRFILE\n\nTo symlink a file to another location. Only works if the environment you use doesn't reboot IOP too soon IE PS2LINK\n\n```pbat\nREDIRFILE \"$PWD$/IPCONFIG.DAT\" \"$BM.BM_PATH$/CONFIG/IPCONFIG.\nDAT\"\n```\n\n`\"$PWD$/IPCONFIG.DAT\"` is where you want the file to \"appear\" and `\"$BM.BM_PATH$/CONFIG/IPCONFIG.DAT\"` is where the file currently resides.",
    "UNMOUNT": "## UNMOUNT\nTo unmount a device such as HDD\n\n```pbat\nUNMOUNT \"pfs0:\"\n```",
    "FPRINT": "## FPRINT\nTo write out text into a file.\n\n```pbat\nFPRINT \"mass:/MY_TEXT.TXT\"  \"This text will be written into MY_TEXT.TXT.\"\n```\nBe careful, if the file exists already, the content will be replaced though a bug does exist where text is appended instead of file replaced especially if file has line breaks.",
    "LOADEXEC": "## LOADEXEC\nTo call/execute another section of the same or different script, elf or irx and pass variables or args as `ARG1`-`ARGX`\n\n```pbat\nLOADEXEC \"TYPE\" \"ARG0\" \"ARG1\" \"ARG2\"\n```\nWill execute a \"TYPE\" of loadexec: `PBAT`,`PBATS`, `EEELF`, `IRX`\n\n### PBAT\nTo execute another PBAT script and pass variables.\n\n```pbat\nLOADEXEC \"PBAT\" \"MY_FILE.PBT\" \"MY_ARGUMENT1\" \"MY_ARGUMENT2\"\n```\nwill execute a PBAT file named MY_FILE.PBT and GOTO section \"MY_ARGUMENT1\" (ARG1) with \"MY_ARGUMENT2\" set as variable ARG2. Most of the time, you'll specify a section of the same PBAT script to be executed as the argument.\n\nIn the called script, MY_ARGUMENT2 will be the first variable in the afformentioned called script, which can be recalled in said script with `$ARG2$`\n\n### PBATS\nTo execute multiple PBAT scripts and pass variables.\n\n```pbat\nLOADEXEC \"PBATS\" \"MY_*.PBT\" \"MY_ARGUMENT1\" \"MY_ARGUMENT2\"\n```\n\nPBATS is usually used to call multiple scripts to print APPS,DEVS,THEMS,LANGS to screen as choices. In the called PBAT GOTO section will most likely be ADDWIDGET \"CALL\"...to pass ARGS back to this script.\n\nIn the called script, MY_ARGUMENT2 will be the first variable in the afformentioned called script, which can be recalled in said script with `$ARG2$`\n\n### EEELF\nTo execute an ELF file and pass arguments.\n\n```pbat\nLOADEXEC \"EEELF\" \"MY_FILE.ELF\" \"MY_ARGUMENT1\" \"MY_ARGUMENT2\"\n```\nwill execute MY_FILE.ELF with MY_ARGUMENT1 and MY_ARGUMENT2 passed to the elf should it support arg(v).\n\n### IRX\nTo load a an IRX module. Most IRXs do not support arg(v).\n\n```pbat\nLOADEXEC \"IRX\" \"MY_FILE.IRX\"\n```\nwill execute an IRX (device driver usually) to add functionality to BOOTMANAGER. Most IRXs do not support arg(v).",
    "KEEP": "## KEEP\nLoads script in ram for quicker recall\n\n```pbat\nKEEP\n```",
    "RETURN": "## RETURN\nRemove the script from memory if the return value is <0\n\n```pbat\nRETURN 0\n```",
    "EXIT": "## EXIT\nExit from the script (0 )and do not keep it in memory (-1)\n\n```pbat\nEXIT 0\n```",
    "KILLSESS": "## KILLSESS\nI believe to exit a script and not keep in memory FROM another script that is currently \"running\". Reference BM/SCRIPTS/BMMENUS.PBT\n\n```pbat\nKILLSESS \"$BM.SCRIPTS$/CONFMENU.PBT\"\n```",
    "SKIPBACK": "## SKIPBACK\nWhen returning from a submenu, this menu is skipped(ie returns to the menu before this menu).\n\n```pbat\nSKIPBACK\n```",
    "LOADIMG": "## LOADIMG\nLoad an image for a theme\n\n```pbat\nLOADIMG \"mc0:/BM/THMS/MYTHEME/IMAGE.BMP\"\n```",
    "UNLOADIMG": "## UNLOADIMG\nUnload an image for a theme\n\n```pbat\nLOADIMG \"mc0:/BM/THMS/MYTHEME/IMAGE.BMP\"\n```",
    "PARSEPATH": "## PARSEPATH\nTo be able to recall specifc parts or whole path of script.\n\n```pbat\nPARSEPATH \"$PWD$\" \"SRC_DEV\" \"SRC_PATH\" \"SRC_FILE\" \n```\nWill let you call Path working directory, source device, source path and source file.\n\nNote: you can always call `$PWD$`, but the others require `PARSEPATH` to define and recall.\n\n### Crystal Chip Info\n- `$BM.MAJOR_VER$` - BootManager major version\n- `$BM.MINOR_VER$` - BootManager minor version\n- `$BM.PATCH_VER$` - BootManager patch version\n- `$BM.CC_MAJOR_VER$` - Crystal Chip major version\n- `$BM.CC_MINOR_VER$` - Crystal Chip minor version\n- `$BM.BM_PATH$` - Path to root BM folder ie `device:/BM` Note there is no `/` included\n- `$BM.SCRIPTS$` - Path to BOOTMANAGER scripts folder. Typically device:/BM/SCRIPTS Note there is no `/` included\n- `$BM.DRIVER_PATH$` - Path to SHARED folder. Typically device:/BM/SHARED Note there is no `/` included\n\n### PS2 Info\n- `$BM.CONSOLE_MODEL$` - PS2 Console model IE SCPH-70012 (best model!)\n- `$BM.CONSOLE_REGION$` - PS2 Console Region\n- `$BM.BIOS_MAJOR_VER$` - PS2 BOOTROM major version\n- `$BM.BIOS_MINOR_VER$` - PS2 BOOTROM minor version\n- `$BM.ROMVER_REGION$` - PS2 BOOTROM Region\n- `$BM.MECHA_REGION$` - PS2 Mechacon Region",
    "SETAUTH": "## SETAUTH\nSet disc type forced authentication:\n\n- `OFF`\n- `PS1`\n- `PS2`\n\n```pbat\nSETAUTH \"PS2\"\n```",
    "SETBIOS": "## SETBIOS\nSet the bios pathes type:\n\n- `OFF`\n- `PS1`\n- `PS2`\n\n```pbat\nSETBIOS \"PS2\"\n```",
    "SHUTDOWN": "## SHUTDOWN\nShutdown portions of how Crystal Chips work:\n\n- `ALL`\n- `MM` - Memory Module\n- `MMIOP` - Memory Module on IOP\n\n```pbat\nSHUTDOWN \"MM\"\n```",
    "PEEK": "Placeholder",
    "POKE": "Placeholder",
    "GETDISKTYPE": "## GETDISKTYPE\nGets disk type as hex value \"0xXX\"\n\n```pbat\nGETDISKTYPE \"DISK_TYPE\"\n```",
    "PARSECNF": "## PARSCNF\nParses CNF file on root of disk to store as variable. Reference BM/SCRIPTS/BMCONT.PBT\n\n```pbat\nPARSECNF \"cdrom0:\\SYSTEM.CNF\" \"BM.BOOT_TYPE\" \"BM.BOOT_NAME\"\n```",
    "CYCLETRAY": "## CYCLETRAY\nCauses the CDVD drive to recheck the disc. Parameters can be WAIT, NOWAIT or nothing (which is the same as WAIT). WAIT means \"wait until disc has authenticated and fail if disc does not authenticate\". NOWAIT returns immediately after telling the CDVD drive to reauthenticate.\n\n```pbat\nCYCLETRAY \"WAIT\"\n```",
    "LOADSRAM": "## LOADSRAM\nUsed to pass PS1 logo check without displaying logo\n\n```pbat\nLOADSRAM \"mc0:/BOOT/BM/PS1LOGO.BIN\"\n```\nFor BOOTROM 2.00 and lower (SCPH-700XX or earlier)\n\n```pbat\nLOADSRAM \"mc0:/BOOT/BM/PS1LOGO2.BIN\"\n```\nFor BOOTROM 2.20 and greater (SCPH-750XX or later)",
    "REBOOTIOP": "## REBOOTIOP\nReboot IOP and reload modules\n\n```pbat\nREBOOTIOP \"rom0:UDNL rom0:OSDCNF\"\n```"
}